// This header includes functions, which build suffix array for string for time O(nlogn).
// 
#ifndef SUFFIX_ARRAY_H
#define SUFFIX_ARRAY_H

#include <vector>
#include <string>
#include <cmath>
#include <algorithm>

std::vector<int> BuildSuffixArray(const std::string& string);
std::vector<int> SortCyclicPermutationsOfString(const std::string& string);

/*
std::vector<int> BuildSuffixArray(const std::string& string) {
    // 
	std::vector<int> places(string.size()); // vecrtor with places of current sorted substrings
											// at the end of this function it will be 
	return;
} */

std::vector<int> SortCyclicPermutationsOfString(const std::string& string) {
	// Эта функция возвращает вектор отсортированной последовательности перестановок входной строки
	// Сортировка похожа на поразрядную сортировку 
	const size_t kCapacityOfAlphabet = 256; // Мощность алфавита, из которого сделана строка
	std::vector<int> places(string.size()); // результат текущего шага сортировки
	std::vector<int> classes(string.size()); // каждая из перестановок соответствует некоторуму классу эквивалентности
	int quantity_of_different_classes = 0; // текущее количество классов эквивалентности
	// 1) Инициализация, т.е. сортировка по первому символу строки(сортировка подсчетом)
	std::vector<int> quantity_of_symbol(std::max(kCapacityOfAlphabet, string.size()), 0); // количество каждого символа
	for (int i = 0; i < string.size(); ++i) { // считаем кол-во вхождений каждого символа
		++quantity_of_symbol[string[i]];
	}
	for (int i = 1; i < string.size(); ++i) { 
		// переводим количество символов в позицию конца их встречаемости в текущем шаге сортировки  
		quantity_of_symbol[i] += quantity_of_symbol[i - 1];
	}
	for (int i = 0; i < string.size(); ++i) { // заполняем массив places с учетом результата подсчета
		places[quantity_of_symbol[string[i]] - 1] = i;
		--quantity_of_symbol[string[i]];
	}
	classes[places[0]] = 0;
	quantity_of_different_classes = 1;
	for (int i = 1; i < string.size(); ++i) { // присваиваем классы эквивалентности
		if (string[places[i]] != string[places[i - 1]]) { // если встретили следующий новый символ
			++quantity_of_different_classes; // то он принадлежит новому классу эквивалентности
		}
		classes[places[i]] = quantity_of_different_classes - 1;
	}
	// 2) Зная сортировку строк длины k, сортируем строки длины 2k
	std::vector<int> places_new(string.size()); // позиции сортировки для следующего шага
	std::vector<int> classes_new(string.size()); // классы эквивалентности для следующего шага
	for (int step = 0; (1 << step) < string.size(); ++step) { // шаг сортировки; шагаем, пока номер шага < log2(n) 
		for (int i = 0; i < string.size(); ++i) {
			places_new[i] = places[i] - (1 << step); // LSD сортировка
			if (places_new[i] < 0) { // учитываем сортировку по второй половине
				places_new[i] += string.size(); // в случае, если вышли за пределы
			}
		}
		std::fill(quantity_of_symbol.begin(), quantity_of_symbol.end(), 0);
		// теперь аналогично предыдущему, но сортировка по первой половине слов 
		for (int i = 0; i < string.size(); ++i) { 
			++quantity_of_symbol[classes[places_new[i]]];
		}
		for (int i = 1; i < quantity_of_different_classes; ++i) {
			quantity_of_symbol[i] += quantity_of_symbol[i - 1];
		}
		for (int i = string.size() - 1; i >= 0; --i) { // назначаем новые места
			places[quantity_of_symbol[classes[places_new[i]]] - 1] = places_new[i];
			--quantity_of_symbol[classes[places_new[i]]];
		}
		classes_new[places[0]] = 0;
		quantity_of_symbol[places[0]] = 1;
		for (int i = 1; i < string.size(); ++i) { // назначаем новые классы эквивалентности
			int mid_element1 = (places[i] + (1 << step)) % string.size();
			int mid_element2 = (places[i - 1] + (1, step)) % string.size();
			// сравнение слов производится как по порвой половине слов, так и по второй
			if (classes[places[i]] != classes[places[i - 1]] || classes[mid_element1] != classes[mid_element2]) {
				++quantity_of_different_classes;
			}
			classes_new[places[i]] = quantity_of_different_classes - 1;
		}
		classes = std::move(classes_new); // готовим вектор classes к новому шагу
	}
	return places;
}

#endif // SUFFIX_ARRAY_H